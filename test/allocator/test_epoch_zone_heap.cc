/*
 *  (c) Copyright 2016-2017 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <unistd.h> // sleep
#include <gtest/gtest.h>
#include "nvmm/memory_manager.h"
#include "test_common/test.h"

using namespace nvmm;

TEST(EpochZoneHeap, Free)
{
    PoolId pool_id = 1;
    size_t size = 128*1024*1024LLU; // 128 MB

    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = NULL;

    // create a heap
    EXPECT_EQ(ID_NOT_FOUND, mm->FindHeap(pool_id, &heap));
    EXPECT_EQ(NO_ERROR, mm->CreateHeap(pool_id, size));
    EXPECT_EQ(ID_FOUND, mm->CreateHeap(pool_id, size));

    // get the heap
    EXPECT_EQ(NO_ERROR, mm->FindHeap(pool_id, &heap));
    EXPECT_EQ(NO_ERROR, heap->Open());

    // allocate & free
    GlobalPtr ptr = heap->Alloc(sizeof(int));
    heap->Free(ptr);

    // allocate again, because of immediate free, the new ptr should be the same as the previous ptr
    GlobalPtr ptr1 = heap->Alloc(sizeof(int));
    EXPECT_EQ(ptr, ptr1);
    heap->Free(ptr1);

    // destroy the heap
    EXPECT_EQ(NO_ERROR, heap->Close());
    delete heap;
    EXPECT_EQ(NO_ERROR, mm->DestroyHeap(pool_id));
    EXPECT_EQ(ID_NOT_FOUND, mm->DestroyHeap(pool_id));
}

TEST(EpochZoneHeap, DelayedFree)
{
    PoolId pool_id = 1;
    size_t size = 128*1024*1024LLU; // 128 MB

    MemoryManager *mm = MemoryManager::GetInstance();
    EpochManager *em = EpochManager::GetInstance();
    Heap *heap = NULL;

    // create a heap
    EXPECT_EQ(ID_NOT_FOUND, mm->FindHeap(pool_id, &heap));
    EXPECT_EQ(NO_ERROR, mm->CreateHeap(pool_id, size));
    EXPECT_EQ(ID_FOUND, mm->CreateHeap(pool_id, size));

    // get the heap
    EXPECT_EQ(NO_ERROR, mm->FindHeap(pool_id, &heap));
    EXPECT_EQ(NO_ERROR, heap->Open());


    EpochCounter e1;
    GlobalPtr ptr1;

    // allocate & delayed free
    {
        EpochOp op(em);
        e1 = op.reported_epoch();
        std::cout << "first epoch " << e1 << std::endl;
        ptr1 = heap->Alloc(op, sizeof(int));
        heap->Free(op, ptr1);
        // allocate again, because of delayed free, the new ptr should be different from t he
        // previous ptr
        GlobalPtr ptr2 = heap->Alloc(op, sizeof(int));
        EXPECT_NE(ptr1, ptr2);
        heap->Free(op, ptr2);
    }

    // wait a few epoches and make sure the background thread picks up this chunk and frees it
    EpochCounter e2;
    while(1)
    {
        {
            // Begin epoch in a new scope block so that we exit the epoch when 
            // we out of scope and don't block others when we then sleep. 
	    {
            	EpochOp op(em);
            	e2 = op.reported_epoch();
	    }
            if (e2-e1>=3 && e2%5 == (e1+3)%5) {
                std::cout << "sleeping at epoch " << e2 << std::endl;
                sleep(1); // making sure the background thread wakes up in this epoch
                break;
            }
        }
    }

    while(1)
    {
        {
            EpochOp op(em);
            EpochCounter e3 = op.reported_epoch();
            if (e3>e2) {
                break;
            }
        }
    }

    // now the ptr that was delayed freed must have been actually freed
    {
        EpochOp op(em);
        std::cout << "final epoch " << op.reported_epoch() << std::endl;
        GlobalPtr ptr2 = heap->Alloc(op, sizeof(int));
        EXPECT_EQ(ptr1, ptr2);
        heap->Free(ptr2);
    }

    // destroy the heap
    EXPECT_EQ(NO_ERROR, heap->Close());
    delete heap;
    EXPECT_EQ(NO_ERROR, mm->DestroyHeap(pool_id));
    EXPECT_EQ(ID_NOT_FOUND, mm->DestroyHeap(pool_id));
}

int main(int argc, char** argv)
{
    InitTest(nvmm::trace, false);
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
