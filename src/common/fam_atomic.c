/*
 *  (c) Copyright 2024 Hewlett Packard Enterprise Development Company LP.
 *
 *  Author: Jason Low <jason.low2@hpe.com>
 *
 *  This software is available to you under a choice of one of two
 *  licenses. You may choose to be licensed under the terms of the
 *  GNU Lesser General Public License Version 3, or (at your option)
 *  later with exceptions included below, or under the terms of the
 *  MIT license (Expat) available in COPYING file in the source tree.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include "nvmm/nvmm_fam_atomic.h"

void fam_spin_lock_init(struct fam_spinlock *lock) {
    fam_atomic_64_write(&lock->head_tail, 0);
}

void fam_spin_lock(struct fam_spinlock *lock) {
    struct fam_spinlock inc = {.tickets = {.head = 0, .tail = 1}};

    /* Fetch the current values and bump the tail by one */
    inc.head_tail = fam_atomic_64_fetch_add(&lock->head_tail, inc.head_tail);

    if (inc.tickets.head != inc.tickets.tail) {
        for (;;) {
            inc.tickets.head = fam_atomic_32_fetch_add(&lock->tickets.head, 0);
            if (inc.tickets.head == inc.tickets.tail)
                break;
        }
    }
    __sync_synchronize();
}

bool fam_spin_trylock(struct fam_spinlock *lock) {
    struct fam_spinlock old, new;
    bool ret;

    old.head_tail = fam_atomic_64_fetch_add(&lock->head_tail, (int64_t)0);
    if (old.tickets.head != old.tickets.tail)
        return 0;

    new.tickets.head = old.tickets.head;
    new.tickets.tail = old.tickets.tail + 1;
    ret = fam_atomic_64_compare_store(&lock->head_tail, old.head_tail,
                                      new.head_tail) == old.head_tail;
    __sync_synchronize();
    return ret;
}

void fam_spin_unlock(struct fam_spinlock *lock) {
    (void)fam_atomic_32_fetch_add(&lock->tickets.head, 1);
    __sync_synchronize();
}

int fam_atomic_register_region(void *region_start, size_t region_length, int fd,
                               off_t offset) {
    return 0;
}

void fam_atomic_unregister_region(void *region_start, size_t region_length) {
    return;
}
