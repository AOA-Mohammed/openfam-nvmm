/*
 *  (c) Copyright 2016-2017 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <memory>

#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
#include <fcntl.h> // for O_RDWR
#include <sys/mman.h> // for PROT_READ, PROT_WRITE, MAP_SHARED
#include <unistd.h> // for getpagesize()
#include <string>
#include <boost/filesystem.hpp>

#include "nvmm/error_code.h"
#include "nvmm/shelf_id.h" // for PoolId
#include "nvmm/global_ptr.h" // for GlobalPtr
#include "nvmm/heap.h"
#include "nvmm/region.h"

#include "nvmm/log.h"
#include "nvmm/nvmm_fam_atomic.h"
#include "nvmm/memory_manager.h"

#include "common/root_shelf.h"
#include "shelf_mgmt/shelf_manager.h"
#include "allocator/pool_region.h"
#ifdef ZONE
#include "allocator/epoch_zone_heap.h"
#else
#include "allocator/dist_heap.h"
#endif

namespace nvmm {

/*
 * Internal implementation of MemoryManager
 */
class MemoryManager::Impl_
{
public:
    static std::string const kRootShelfPath; // path of the root shelf

    Impl_()
        : is_ready_(false), root_shelf_(kRootShelfPath), locks_(NULL), types_(NULL)
    {
    }

    ~Impl_()
    {
    }

    ErrorCode Init();
    ErrorCode Final();

    ErrorCode MapPointer(GlobalPtr ptr, size_t size,
                         void *addr_hint, int prot, int flags, void **mapped_addr);
    ErrorCode UnmapPointer(GlobalPtr ptr, void *mapped_addr, size_t size);

    void *GlobalToLocal(GlobalPtr ptr);
    GlobalPtr LocalToGlobal(void *addr);

    ErrorCode CreateHeap(PoolId id, size_t shelf_size);
    ErrorCode DestroyHeap(PoolId id);
    ErrorCode FindHeap(PoolId id, Heap **heap);
    Heap *FindHeap(PoolId id);

    ErrorCode CreateRegion(PoolId id, size_t size);
    ErrorCode DestroyRegion(PoolId id);
    ErrorCode FindRegion(PoolId id, Region **region);
    Region *FindRegion(PoolId id);

private:
    enum PoolType {
        NONE=0,
        REGION,
        HEAP
    }; // __attribute__((__aligned__(64))) does not work for enum type???

    struct PoolTypeEntry {
        PoolType type;
    } __attribute__((__aligned__(64)));

    // multi-process/multi-node
    // TODO: NOT resilient to crashes, need the epoch system
    inline void Lock(PoolId pool_id)
    {
        locks_[pool_id].lock();
    }

    inline void Unlock(PoolId pool_id)
    {
        locks_[pool_id].unlock();
    }

    inline bool TryLock(PoolId pool_id)
    {
        return locks_[pool_id].trylock();
    }

    inline void SetType(PoolId pool_id, PoolType pool_type)
    {
        fam_atomic_u64_write((uint64_t*)&types_[pool_id], (uint64_t)pool_type);
    }

    inline PoolType GetType(PoolId pool_id)
    {
        return (PoolType)fam_atomic_u64_read((uint64_t*)&types_[pool_id]);
    }

    bool is_ready_;
    RootShelf root_shelf_;
    nvmm_fam_spinlock* locks_; // an array of fam_spinlock
    PoolTypeEntry *types_; // store pool types
};

std::string const MemoryManager::Impl_::kRootShelfPath = std::string(SHELF_BASE_DIR) + "/" + SHELF_USER + "_NVMM_ROOT";

ErrorCode MemoryManager::Impl_::Init()
{
    boost::filesystem::path shelf_base_path = boost::filesystem::path(SHELF_BASE_DIR);
    if (boost::filesystem::exists(shelf_base_path) == false)
    {
        LOG(fatal) << "NVMM: LFS/tmpfs does not exist?" << SHELF_BASE_DIR;
        exit(1);
    }

    if (root_shelf_.Exist() == false)
    {
        LOG(fatal) << "NVMM: Root shelf does not exist?" << kRootShelfPath;
        exit(1);
    }

    if (root_shelf_.Open() != NO_ERROR)
    {
        LOG(fatal) << "NVMM: Root shelf open failed..." << kRootShelfPath;
        exit(1);
    }

    locks_ = (nvmm_fam_spinlock*)root_shelf_.Addr();
    types_ = (PoolTypeEntry*)((char*)root_shelf_.Addr() + ShelfId::kMaxPoolCount*sizeof(nvmm_fam_spinlock));
    is_ready_ = true;
    return NO_ERROR;
}

ErrorCode MemoryManager::Impl_::Final()
{
    ErrorCode ret = root_shelf_.Close();
    if (ret!=NO_ERROR)
    {
        LOG(fatal) << "NVMM: Root shelf close failed" << kRootShelfPath;
        exit(1);
    }

    is_ready_ = false;
    return NO_ERROR;
}

ErrorCode MemoryManager::Impl_::CreateRegion(PoolId id, size_t size)
{
    assert(is_ready_ == true);
    assert(id > 0);
    ErrorCode ret = NO_ERROR;
    Lock(id);
    if (GetType(id)!=PoolType::NONE)
    {
        Unlock(id);
        LOG(error) << "MemoryManager: the given id (" << (uint64_t)id << ") is in use";
        return ID_FOUND;
    }
    PoolRegion pool_region(id);
    ret = pool_region.Create(size);
    if (ret == NO_ERROR)
    {
        SetType(id, PoolType::REGION);
        Unlock(id);
        return ret;
    }
    Unlock(id);
    if (ret == POOL_FOUND)
    {
        LOG(error) << "MemoryManager: the given id (" << (uint64_t)id << ") is in use";
        return ID_FOUND;
    }
    else
    {
        LOG(fatal) << "MemoryManager: error " << ret;
        return ID_FOUND;
    }
}

// TODO: verify the pool is indeed a region
ErrorCode MemoryManager::Impl_::DestroyRegion(PoolId id)
{
    assert(is_ready_ == true);
    assert(id > 0);
    ErrorCode ret = NO_ERROR;
    Lock(id);
    if (GetType(id)!=PoolType::REGION)
    {
        Unlock(id);
        LOG(error) << "MemoryManager: region of the given id (" << (uint64_t)id << ") is not found";
        return ID_NOT_FOUND;
    }
    PoolRegion pool_region(id);
    ret = pool_region.Destroy();
    if (ret == NO_ERROR)
    {
        SetType(id, PoolType::NONE);
        Unlock(id);
        return NO_ERROR;
    }
    Unlock(id);
    if (ret == POOL_NOT_FOUND)
    {
        LOG(error) << "MemoryManager: region of the given id (" << (uint64_t)id << ") is not found";
        return ID_NOT_FOUND;
    }
    else
    {
        LOG(fatal) << "MemoryManager: error " << ret;
        return ID_NOT_FOUND;
    }
}

ErrorCode MemoryManager::Impl_::FindRegion(PoolId id, Region **region)
{
    assert(is_ready_ == true);
    assert(id > 0);
    Lock(id);
    if (GetType(id)!=PoolType::REGION)
    {
        Unlock(id);
        LOG(error) << "MemoryManager: region of the given id (" << (uint64_t)id << ") is not found";
        return ID_NOT_FOUND;
    }
    // TODO: use smart poitner or unique pointer?
    PoolRegion *pool_region = new PoolRegion(id);
    assert(pool_region != NULL);
    Unlock(id);
    if (pool_region->Exist() == true)
    {
        *region = (Region*)pool_region;
        return NO_ERROR;
    }
    else
    {
        LOG(error) << "MemoryManager: region of the given id (" << (uint64_t)id << ") is not found";
        delete pool_region;
        return ID_NOT_FOUND;
    }
}

Region *MemoryManager::Impl_::FindRegion(PoolId id)
{
    assert(is_ready_ == true);
    assert(id > 0);
    Region *ret = NULL;
    (void)FindRegion(id, &ret);
    return ret;
}

ErrorCode MemoryManager::Impl_::CreateHeap(PoolId id, size_t size)
{
    assert(is_ready_ == true);
    assert(id > 0);
    ErrorCode ret = NO_ERROR;
    Lock(id);
    if (GetType(id)!=PoolType::NONE)
    {
        Unlock(id);
        LOG(error) << "MemoryManager: the given id (" << (uint64_t)id << ") is in use";
        return ID_FOUND;
    }
#ifdef ZONE
    EpochZoneHeap heap(id);
#else
    DistHeap heap(id);
#endif
    ret = heap.Create(size);
    if (ret == NO_ERROR)
    {
        SetType(id, PoolType::HEAP);
        Unlock(id);
        return ret;
    }
    Unlock(id);
    if (ret == POOL_FOUND)
    {
        LOG(error) << "MemoryManager: the given id (" << (uint64_t)id << ") is in use";
        return ID_FOUND;
    }
    else
    {
        LOG(fatal) << "MemoryManager: error " << ret;
        return ID_FOUND;
    }
}

ErrorCode MemoryManager::Impl_::DestroyHeap(PoolId id)
{
    assert(is_ready_ == true);
    assert(id > 0);
    ErrorCode ret = NO_ERROR;
    Lock(id);
    if (GetType(id)!=PoolType::HEAP)
    {
        Unlock(id);
        LOG(error) << "MemoryManager: heap of the given id (" << (uint64_t)id << ") is not found";
        return ID_NOT_FOUND;
    }
#ifdef ZONE
    EpochZoneHeap heap(id);
#else
    //PoolHeap heap(id);
    DistHeap heap(id);
#endif
    ret = heap.Destroy();
    if (ret == NO_ERROR)
    {
        SetType(id, PoolType::NONE);
        Unlock(id);
        return NO_ERROR;
    }
    Unlock(id);
    if (ret == POOL_NOT_FOUND)
    {
        LOG(error) << "MemoryManager: heap of the given id (" << (uint64_t)id << ") is not found";
        return ID_NOT_FOUND;
    }
    else
    {
        LOG(fatal) << "MemoryManager: error " << ret;
        return ID_NOT_FOUND;
    }
}

ErrorCode MemoryManager::Impl_::FindHeap(PoolId id, Heap **heap)
{
    assert(is_ready_ == true);
    assert(id > 0);
    Lock(id);
    if (GetType(id)!=PoolType::HEAP)
    {
        Unlock(id);
        LOG(error) << "MemoryManager: heap of the given id (" << (uint64_t)id << ") is not found";
        return ID_NOT_FOUND;
    }
    // TODO: use smart poitner or unique pointer?
#ifdef ZONE
    EpochZoneHeap *heap_ = new EpochZoneHeap(id);
#else
    DistHeap *heap_ = new DistHeap(id);
#endif
    assert(heap_ != NULL);
    Unlock(id);
    if(heap_->Exist() == true)
    {
        *heap = (Heap*)heap_;
        return NO_ERROR;
    }
    else
    {
        LOG(error) << "MemoryManager: heap of the given id (" << (uint64_t)id << ") is not found";
        return ID_NOT_FOUND;
    }
}

Heap *MemoryManager::Impl_::FindHeap(PoolId id)
{
    assert(is_ready_ == true);
    assert(id > 0);
    Heap *ret = NULL;
    (void)FindHeap(id, &ret);
    return ret;
}

ErrorCode MemoryManager::Impl_::MapPointer(GlobalPtr ptr, size_t size,
                                    void *addr_hint, int prot, int flags, void **mapped_addr)
{
    assert(is_ready_ == true);

    if (ptr.IsValid() == false)
    {
        LOG(error) << "MemoryManager: Invalid Global Pointer: " << ptr;
        return INVALID_PTR;
    }

    ErrorCode ret = NO_ERROR;
    ShelfId shelf_id = ptr.GetShelfId();
    PoolId pool_id = shelf_id.GetPoolId();
    if (pool_id == 0)
    {
        LOG(error) << "MemoryManager: Invalid Global Pointer: " << ptr;
        return INVALID_PTR;
    }
    ShelfIndex shelf_idx = shelf_id.GetShelfIndex();
    Offset offset = ptr.GetOffset();

    // handle alignment
    int page_size = getpagesize();
    off_t aligned_start = offset - offset % page_size;
    assert(aligned_start % page_size == 0);
    off_t aligned_end = (offset + size) + (page_size - (offset + size) % page_size);
    assert(aligned_end % page_size == 0);
    size_t aligned_size = aligned_end - aligned_start;
    assert(aligned_size % page_size == 0);

    void *aligned_addr = NULL;

    // TODO: this is way too costly
    // open the pool
    Pool pool(pool_id);
    ret = pool.Open(false);
    if (ret != NO_ERROR)
    {
        return MAP_POINTER_FAILED;
    }

    std::string shelf_path;
    ret = pool.GetShelfPath(shelf_idx, shelf_path);
    if (ret != NO_ERROR)
    {
        return MAP_POINTER_FAILED;
    }

    ShelfFile shelf(shelf_path);

    // open the shelf file
    ret = shelf.Open(O_RDWR);
    if (ret != NO_ERROR)
    {
        return MAP_POINTER_FAILED;
    }

    // only mmap offset + size
    ret = shelf.Map(addr_hint, aligned_size, PROT_READ|PROT_WRITE, MAP_SHARED, aligned_start,
                    &aligned_addr, false);
    if (ret != NO_ERROR)
    {
        return MAP_POINTER_FAILED;
    }

    // close the shelf file
    ret = shelf.Close();
    if (ret != NO_ERROR)
    {
        return MAP_POINTER_FAILED;
    }

    // close the pool
    ret = pool.Close(false);
    if (ret != NO_ERROR)
    {
        return MAP_POINTER_FAILED;
    }

    *mapped_addr = (void*)((char*)aligned_addr + offset % page_size);

    LOG(trace) << "MapPointer: path " << shelf.GetPath()
               << " offset " << aligned_start << " size " << aligned_size
               << " aligned ptr " << (void*)aligned_addr
               << " returned ptr " << (void*)(*mapped_addr);

    return ret;

}

ErrorCode MemoryManager::Impl_::UnmapPointer(GlobalPtr ptr, void *mapped_addr, size_t size)
{
    assert(is_ready_ == true);
    Offset offset = ptr.GetOffset();
    int page_size = getpagesize();
    off_t aligned_start = offset - offset % page_size;
    assert(aligned_start % page_size == 0);
    off_t aligned_end = (offset + size) + (page_size - (offset + size) % page_size);
    assert(aligned_end % page_size == 0);
    size_t aligned_size = aligned_end - aligned_start;
    assert(aligned_size % page_size == 0);
    void *aligned_addr = (void*)((char*)mapped_addr - offset % page_size);
    LOG(trace) << "UnmapPointer: path " << " offset " << aligned_start << " size " << aligned_size
               << " aligned ptr " << (void*)aligned_addr
               << " input ptr " << (void*)mapped_addr;
    return ShelfFile::Unmap(aligned_addr, aligned_size, false);
}

void *MemoryManager::Impl_::GlobalToLocal(GlobalPtr ptr)
{
    assert(is_ready_ == true);

    if (ptr.IsValid() == false)
    {
        LOG(error) << "MemoryManager: Invalid Global Pointer: " << ptr;
        return NULL;
    }
    
    ErrorCode ret = NO_ERROR;
    ShelfId shelf_id = ptr.GetShelfId();
    Offset offset = ptr.GetOffset();
    void *addr = ShelfManager::FindBase(shelf_id);
    if (addr == NULL)
    {
        // slow path
        // first time accessing this shelf        
        PoolId pool_id = shelf_id.GetPoolId();
        if (pool_id == 0)
        {
            LOG(error) << "MemoryManager: Invalid Global Pointer: " << ptr;
            return NULL;
        }
        // TODO: this is way too expensive
        // open the pool
        Pool pool(pool_id);
        ret = pool.Open(false);
        if (ret != NO_ERROR)
        {
            return NULL;
        }

        ShelfIndex shelf_idx = shelf_id.GetShelfIndex();
        std::string shelf_path;    
        ret = pool.GetShelfPath(shelf_idx, shelf_path);
        if (ret != NO_ERROR)
        {
            return NULL;
        }

        addr = ShelfManager::FindBase(shelf_path, shelf_id);

        // close the pool
        (void) pool.Close(false);        
    }

    if (addr != NULL)
    {
        addr = (void*)((char*)addr+offset);
        LOG(trace) << "GetLocalPtr: global ptr" << ptr
                   << " offset " << offset
                   << " returned ptr " << (uintptr_t)addr;
    }
    
    return addr;
}

// TODO(zone): how to make this work for zone ptr?
GlobalPtr MemoryManager::Impl_::LocalToGlobal(void *addr)
{
    void *base = NULL;
    ShelfId shelf_id = ShelfManager::FindShelf(addr, base);
    if (shelf_id.IsValid() == false)
    {
        LOG(error) << "GetGlobalPtr failed";
        return GlobalPtr(); // return an invalid global pointer
    }
    else
    {
        Offset offset = (uintptr_t)addr - (uintptr_t)base;
        GlobalPtr global_ptr = GlobalPtr(shelf_id, offset);
        LOG(trace) << "GetGlobalPtr: local ptr " << (uintptr_t)addr
                   << " offset " << offset
                   << " returned ptr " << global_ptr;
        return global_ptr;
    }
}



/*
 * Public APIs of MemoryManager
 */

void MemoryManager::Start() {
    // Check if SHELF_BASE_DIR exists
    boost::filesystem::path shelf_base_path = boost::filesystem::path(SHELF_BASE_DIR);
    if (boost::filesystem::exists(shelf_base_path) == false)
    {
        LOG(fatal) << "NVMM: LFS/tmpfs does not exist?" << SHELF_BASE_DIR;
        exit(1);
    }

    // create a root shelf for MemoryManager if it does not exist
    RootShelf root_shelf(MemoryManager::Impl_::kRootShelfPath);
    if(root_shelf.Exist() == false)
    {
        ErrorCode ret = root_shelf.Create();
        if (ret!=NO_ERROR && ret != SHELF_FILE_FOUND)
        {
            LOG(fatal) << "NVMM: Failed to create the root shelf file " << MemoryManager::Impl_::kRootShelfPath;
            exit(1);
        }
    }
}

void MemoryManager::Reset() {
    std::string cmd = std::string("exec rm -f ") + MemoryManager::Impl_::kRootShelfPath + " > /dev/null";
    (void)system(cmd.c_str());

    // remove previous files in SHELF_BASE_DIR
    cmd = std::string("exec rm -f ") + SHELF_BASE_DIR + "/" + SHELF_USER + "_NVMM_Shelf* > /dev/null";
    (void)system(cmd.c_str());
}

// thread-safe Singleton pattern with C++11
// see http://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/
MemoryManager *MemoryManager::GetInstance()
{
    static MemoryManager instance;
    return &instance;
}

MemoryManager::MemoryManager()
    : pimpl_{new Impl_}
{
    ErrorCode ret = pimpl_->Init();
    assert(ret == NO_ERROR);
}

MemoryManager::~MemoryManager()
{
    ErrorCode ret = pimpl_->Final();
    assert(ret == NO_ERROR);
}   

ErrorCode MemoryManager::CreateRegion(PoolId id, size_t size)
{
    return pimpl_->CreateRegion(id, size);
}

ErrorCode MemoryManager::DestroyRegion(PoolId id)
{
    return pimpl_->DestroyRegion(id);
}
    
ErrorCode MemoryManager::FindRegion(PoolId id, Region **region)
{
    return pimpl_->FindRegion(id, region);
}

Region *MemoryManager::FindRegion(PoolId id)
{
    return pimpl_->FindRegion(id);
}   
    
ErrorCode MemoryManager::CreateHeap(PoolId id, size_t size)
{
    return pimpl_->CreateHeap(id, size);
}

ErrorCode MemoryManager::DestroyHeap(PoolId id)
{
    return pimpl_->DestroyHeap(id);
}
    
ErrorCode MemoryManager::FindHeap(PoolId id, Heap **heap)
{
    return pimpl_->FindHeap(id, heap);
}

Heap *MemoryManager::FindHeap(PoolId id)
{
    return pimpl_->FindHeap(id);
}   

ErrorCode MemoryManager::MapPointer(GlobalPtr ptr, size_t size,
                                    void *addr_hint, int prot, int flags, void **mapped_addr)
{
    return pimpl_->MapPointer(ptr, size, addr_hint, prot, flags, mapped_addr);
}
    

ErrorCode MemoryManager::UnmapPointer(GlobalPtr ptr, void *mapped_addr, size_t size)
{ 
    return pimpl_->UnmapPointer(ptr, mapped_addr, size);
}

void *MemoryManager::GlobalToLocal(GlobalPtr ptr)
{
    return pimpl_->GlobalToLocal(ptr);
}

GlobalPtr MemoryManager::LocalToGlobal(void *addr)
{
    return pimpl_->LocalToGlobal(addr);
}
    

} // namespace nvmm
